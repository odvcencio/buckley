// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: acp.proto

package acppb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AgentCommunication_RegisterAgent_FullMethodName           = "/buckley.acp.v1.AgentCommunication/RegisterAgent"
	AgentCommunication_UnregisterAgent_FullMethodName         = "/buckley.acp.v1.AgentCommunication/UnregisterAgent"
	AgentCommunication_DiscoverAgents_FullMethodName          = "/buckley.acp.v1.AgentCommunication/DiscoverAgents"
	AgentCommunication_GetAgentInfo_FullMethodName            = "/buckley.acp.v1.AgentCommunication/GetAgentInfo"
	AgentCommunication_GetServerCapabilities_FullMethodName   = "/buckley.acp.v1.AgentCommunication/GetServerCapabilities"
	AgentCommunication_RequestCapabilities_FullMethodName     = "/buckley.acp.v1.AgentCommunication/RequestCapabilities"
	AgentCommunication_RevokeCapabilities_FullMethodName      = "/buckley.acp.v1.AgentCommunication/RevokeCapabilities"
	AgentCommunication_CreateSession_FullMethodName           = "/buckley.acp.v1.AgentCommunication/CreateSession"
	AgentCommunication_UpdateSessionContext_FullMethodName    = "/buckley.acp.v1.AgentCommunication/UpdateSessionContext"
	AgentCommunication_CreateContextHandle_FullMethodName     = "/buckley.acp.v1.AgentCommunication/CreateContextHandle"
	AgentCommunication_ResolveContextHandle_FullMethodName    = "/buckley.acp.v1.AgentCommunication/ResolveContextHandle"
	AgentCommunication_StreamTask_FullMethodName              = "/buckley.acp.v1.AgentCommunication/StreamTask"
	AgentCommunication_SubscribeTaskEvents_FullMethodName     = "/buckley.acp.v1.AgentCommunication/SubscribeTaskEvents"
	AgentCommunication_GetP2PEndpoint_FullMethodName          = "/buckley.acp.v1.AgentCommunication/GetP2PEndpoint"
	AgentCommunication_EstablishP2PConnection_FullMethodName  = "/buckley.acp.v1.AgentCommunication/EstablishP2PConnection"
	AgentCommunication_RequestToolExecution_FullMethodName    = "/buckley.acp.v1.AgentCommunication/RequestToolExecution"
	AgentCommunication_ApproveToolExecution_FullMethodName    = "/buckley.acp.v1.AgentCommunication/ApproveToolExecution"
	AgentCommunication_RejectToolExecution_FullMethodName     = "/buckley.acp.v1.AgentCommunication/RejectToolExecution"
	AgentCommunication_SendMessage_FullMethodName             = "/buckley.acp.v1.AgentCommunication/SendMessage"
	AgentCommunication_StreamInlineCompletions_FullMethodName = "/buckley.acp.v1.AgentCommunication/StreamInlineCompletions"
	AgentCommunication_ProposeEdits_FullMethodName            = "/buckley.acp.v1.AgentCommunication/ProposeEdits"
	AgentCommunication_ApplyEdits_FullMethodName              = "/buckley.acp.v1.AgentCommunication/ApplyEdits"
	AgentCommunication_UpdateEditorState_FullMethodName       = "/buckley.acp.v1.AgentCommunication/UpdateEditorState"
)

// AgentCommunicationClient is the client API for AgentCommunication service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AgentCommunicationClient interface {
	// Agent lifecycle
	RegisterAgent(ctx context.Context, in *RegisterAgentRequest, opts ...grpc.CallOption) (*RegisterAgentResponse, error)
	UnregisterAgent(ctx context.Context, in *UnregisterAgentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DiscoverAgents(ctx context.Context, in *DiscoverAgentsRequest, opts ...grpc.CallOption) (*DiscoverAgentsResponse, error)
	GetAgentInfo(ctx context.Context, in *GetAgentInfoRequest, opts ...grpc.CallOption) (*AgentInfo, error)
	// Capability negotiation
	GetServerCapabilities(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ServerCapabilities, error)
	RequestCapabilities(ctx context.Context, in *CapabilityRequest, opts ...grpc.CallOption) (*CapabilityGrant, error)
	RevokeCapabilities(ctx context.Context, in *CapabilityRevocation, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Context management
	CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*Session, error)
	UpdateSessionContext(ctx context.Context, in *ContextDelta, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateContextHandle(ctx context.Context, in *ContextHandleRequest, opts ...grpc.CallOption) (*ContextHandle, error)
	ResolveContextHandle(ctx context.Context, in *ContextHandle, opts ...grpc.CallOption) (*ContextData, error)
	// Task streaming
	StreamTask(ctx context.Context, in *TaskStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskEvent], error)
	SubscribeTaskEvents(ctx context.Context, in *TaskSubscription, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskEvent], error)
	// P2P introduction
	GetP2PEndpoint(ctx context.Context, in *P2PEndpointRequest, opts ...grpc.CallOption) (*P2PEndpoint, error)
	EstablishP2PConnection(ctx context.Context, in *P2PHandshake, opts ...grpc.CallOption) (*P2PConnectionInfo, error)
	// Tool execution
	RequestToolExecution(ctx context.Context, in *ToolExecutionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ToolExecutionEvent], error)
	ApproveToolExecution(ctx context.Context, in *ToolApproval, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RejectToolExecution(ctx context.Context, in *ToolRejection, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Message exchange (for LSP integration)
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
	// Editor-native flows
	StreamInlineCompletions(ctx context.Context, in *InlineCompletionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InlineCompletionEvent], error)
	ProposeEdits(ctx context.Context, in *ProposeEditsRequest, opts ...grpc.CallOption) (*ProposeEditsResponse, error)
	ApplyEdits(ctx context.Context, in *ApplyEditsRequest, opts ...grpc.CallOption) (*ApplyEditsResponse, error)
	UpdateEditorState(ctx context.Context, in *UpdateEditorStateRequest, opts ...grpc.CallOption) (*UpdateEditorStateResponse, error)
}

type agentCommunicationClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentCommunicationClient(cc grpc.ClientConnInterface) AgentCommunicationClient {
	return &agentCommunicationClient{cc}
}

func (c *agentCommunicationClient) RegisterAgent(ctx context.Context, in *RegisterAgentRequest, opts ...grpc.CallOption) (*RegisterAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterAgentResponse)
	err := c.cc.Invoke(ctx, AgentCommunication_RegisterAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) UnregisterAgent(ctx context.Context, in *UnregisterAgentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AgentCommunication_UnregisterAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) DiscoverAgents(ctx context.Context, in *DiscoverAgentsRequest, opts ...grpc.CallOption) (*DiscoverAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DiscoverAgentsResponse)
	err := c.cc.Invoke(ctx, AgentCommunication_DiscoverAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) GetAgentInfo(ctx context.Context, in *GetAgentInfoRequest, opts ...grpc.CallOption) (*AgentInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentInfo)
	err := c.cc.Invoke(ctx, AgentCommunication_GetAgentInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) GetServerCapabilities(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ServerCapabilities, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerCapabilities)
	err := c.cc.Invoke(ctx, AgentCommunication_GetServerCapabilities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) RequestCapabilities(ctx context.Context, in *CapabilityRequest, opts ...grpc.CallOption) (*CapabilityGrant, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CapabilityGrant)
	err := c.cc.Invoke(ctx, AgentCommunication_RequestCapabilities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) RevokeCapabilities(ctx context.Context, in *CapabilityRevocation, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AgentCommunication_RevokeCapabilities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*Session, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Session)
	err := c.cc.Invoke(ctx, AgentCommunication_CreateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) UpdateSessionContext(ctx context.Context, in *ContextDelta, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AgentCommunication_UpdateSessionContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) CreateContextHandle(ctx context.Context, in *ContextHandleRequest, opts ...grpc.CallOption) (*ContextHandle, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContextHandle)
	err := c.cc.Invoke(ctx, AgentCommunication_CreateContextHandle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) ResolveContextHandle(ctx context.Context, in *ContextHandle, opts ...grpc.CallOption) (*ContextData, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContextData)
	err := c.cc.Invoke(ctx, AgentCommunication_ResolveContextHandle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) StreamTask(ctx context.Context, in *TaskStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentCommunication_ServiceDesc.Streams[0], AgentCommunication_StreamTask_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TaskStreamRequest, TaskEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentCommunication_StreamTaskClient = grpc.ServerStreamingClient[TaskEvent]

func (c *agentCommunicationClient) SubscribeTaskEvents(ctx context.Context, in *TaskSubscription, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentCommunication_ServiceDesc.Streams[1], AgentCommunication_SubscribeTaskEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TaskSubscription, TaskEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentCommunication_SubscribeTaskEventsClient = grpc.ServerStreamingClient[TaskEvent]

func (c *agentCommunicationClient) GetP2PEndpoint(ctx context.Context, in *P2PEndpointRequest, opts ...grpc.CallOption) (*P2PEndpoint, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(P2PEndpoint)
	err := c.cc.Invoke(ctx, AgentCommunication_GetP2PEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) EstablishP2PConnection(ctx context.Context, in *P2PHandshake, opts ...grpc.CallOption) (*P2PConnectionInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(P2PConnectionInfo)
	err := c.cc.Invoke(ctx, AgentCommunication_EstablishP2PConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) RequestToolExecution(ctx context.Context, in *ToolExecutionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ToolExecutionEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentCommunication_ServiceDesc.Streams[2], AgentCommunication_RequestToolExecution_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ToolExecutionRequest, ToolExecutionEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentCommunication_RequestToolExecutionClient = grpc.ServerStreamingClient[ToolExecutionEvent]

func (c *agentCommunicationClient) ApproveToolExecution(ctx context.Context, in *ToolApproval, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AgentCommunication_ApproveToolExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) RejectToolExecution(ctx context.Context, in *ToolRejection, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AgentCommunication_RejectToolExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMessageResponse)
	err := c.cc.Invoke(ctx, AgentCommunication_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) StreamInlineCompletions(ctx context.Context, in *InlineCompletionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InlineCompletionEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentCommunication_ServiceDesc.Streams[3], AgentCommunication_StreamInlineCompletions_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InlineCompletionRequest, InlineCompletionEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentCommunication_StreamInlineCompletionsClient = grpc.ServerStreamingClient[InlineCompletionEvent]

func (c *agentCommunicationClient) ProposeEdits(ctx context.Context, in *ProposeEditsRequest, opts ...grpc.CallOption) (*ProposeEditsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProposeEditsResponse)
	err := c.cc.Invoke(ctx, AgentCommunication_ProposeEdits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) ApplyEdits(ctx context.Context, in *ApplyEditsRequest, opts ...grpc.CallOption) (*ApplyEditsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApplyEditsResponse)
	err := c.cc.Invoke(ctx, AgentCommunication_ApplyEdits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentCommunicationClient) UpdateEditorState(ctx context.Context, in *UpdateEditorStateRequest, opts ...grpc.CallOption) (*UpdateEditorStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateEditorStateResponse)
	err := c.cc.Invoke(ctx, AgentCommunication_UpdateEditorState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentCommunicationServer is the server API for AgentCommunication service.
// All implementations must embed UnimplementedAgentCommunicationServer
// for forward compatibility.
type AgentCommunicationServer interface {
	// Agent lifecycle
	RegisterAgent(context.Context, *RegisterAgentRequest) (*RegisterAgentResponse, error)
	UnregisterAgent(context.Context, *UnregisterAgentRequest) (*emptypb.Empty, error)
	DiscoverAgents(context.Context, *DiscoverAgentsRequest) (*DiscoverAgentsResponse, error)
	GetAgentInfo(context.Context, *GetAgentInfoRequest) (*AgentInfo, error)
	// Capability negotiation
	GetServerCapabilities(context.Context, *emptypb.Empty) (*ServerCapabilities, error)
	RequestCapabilities(context.Context, *CapabilityRequest) (*CapabilityGrant, error)
	RevokeCapabilities(context.Context, *CapabilityRevocation) (*emptypb.Empty, error)
	// Context management
	CreateSession(context.Context, *CreateSessionRequest) (*Session, error)
	UpdateSessionContext(context.Context, *ContextDelta) (*emptypb.Empty, error)
	CreateContextHandle(context.Context, *ContextHandleRequest) (*ContextHandle, error)
	ResolveContextHandle(context.Context, *ContextHandle) (*ContextData, error)
	// Task streaming
	StreamTask(*TaskStreamRequest, grpc.ServerStreamingServer[TaskEvent]) error
	SubscribeTaskEvents(*TaskSubscription, grpc.ServerStreamingServer[TaskEvent]) error
	// P2P introduction
	GetP2PEndpoint(context.Context, *P2PEndpointRequest) (*P2PEndpoint, error)
	EstablishP2PConnection(context.Context, *P2PHandshake) (*P2PConnectionInfo, error)
	// Tool execution
	RequestToolExecution(*ToolExecutionRequest, grpc.ServerStreamingServer[ToolExecutionEvent]) error
	ApproveToolExecution(context.Context, *ToolApproval) (*emptypb.Empty, error)
	RejectToolExecution(context.Context, *ToolRejection) (*emptypb.Empty, error)
	// Message exchange (for LSP integration)
	SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error)
	// Editor-native flows
	StreamInlineCompletions(*InlineCompletionRequest, grpc.ServerStreamingServer[InlineCompletionEvent]) error
	ProposeEdits(context.Context, *ProposeEditsRequest) (*ProposeEditsResponse, error)
	ApplyEdits(context.Context, *ApplyEditsRequest) (*ApplyEditsResponse, error)
	UpdateEditorState(context.Context, *UpdateEditorStateRequest) (*UpdateEditorStateResponse, error)
	mustEmbedUnimplementedAgentCommunicationServer()
}

// UnimplementedAgentCommunicationServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentCommunicationServer struct{}

func (UnimplementedAgentCommunicationServer) RegisterAgent(context.Context, *RegisterAgentRequest) (*RegisterAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterAgent not implemented")
}
func (UnimplementedAgentCommunicationServer) UnregisterAgent(context.Context, *UnregisterAgentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterAgent not implemented")
}
func (UnimplementedAgentCommunicationServer) DiscoverAgents(context.Context, *DiscoverAgentsRequest) (*DiscoverAgentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiscoverAgents not implemented")
}
func (UnimplementedAgentCommunicationServer) GetAgentInfo(context.Context, *GetAgentInfoRequest) (*AgentInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentInfo not implemented")
}
func (UnimplementedAgentCommunicationServer) GetServerCapabilities(context.Context, *emptypb.Empty) (*ServerCapabilities, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServerCapabilities not implemented")
}
func (UnimplementedAgentCommunicationServer) RequestCapabilities(context.Context, *CapabilityRequest) (*CapabilityGrant, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestCapabilities not implemented")
}
func (UnimplementedAgentCommunicationServer) RevokeCapabilities(context.Context, *CapabilityRevocation) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeCapabilities not implemented")
}
func (UnimplementedAgentCommunicationServer) CreateSession(context.Context, *CreateSessionRequest) (*Session, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSession not implemented")
}
func (UnimplementedAgentCommunicationServer) UpdateSessionContext(context.Context, *ContextDelta) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSessionContext not implemented")
}
func (UnimplementedAgentCommunicationServer) CreateContextHandle(context.Context, *ContextHandleRequest) (*ContextHandle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContextHandle not implemented")
}
func (UnimplementedAgentCommunicationServer) ResolveContextHandle(context.Context, *ContextHandle) (*ContextData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveContextHandle not implemented")
}
func (UnimplementedAgentCommunicationServer) StreamTask(*TaskStreamRequest, grpc.ServerStreamingServer[TaskEvent]) error {
	return status.Errorf(codes.Unimplemented, "method StreamTask not implemented")
}
func (UnimplementedAgentCommunicationServer) SubscribeTaskEvents(*TaskSubscription, grpc.ServerStreamingServer[TaskEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTaskEvents not implemented")
}
func (UnimplementedAgentCommunicationServer) GetP2PEndpoint(context.Context, *P2PEndpointRequest) (*P2PEndpoint, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetP2PEndpoint not implemented")
}
func (UnimplementedAgentCommunicationServer) EstablishP2PConnection(context.Context, *P2PHandshake) (*P2PConnectionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstablishP2PConnection not implemented")
}
func (UnimplementedAgentCommunicationServer) RequestToolExecution(*ToolExecutionRequest, grpc.ServerStreamingServer[ToolExecutionEvent]) error {
	return status.Errorf(codes.Unimplemented, "method RequestToolExecution not implemented")
}
func (UnimplementedAgentCommunicationServer) ApproveToolExecution(context.Context, *ToolApproval) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveToolExecution not implemented")
}
func (UnimplementedAgentCommunicationServer) RejectToolExecution(context.Context, *ToolRejection) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RejectToolExecution not implemented")
}
func (UnimplementedAgentCommunicationServer) SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedAgentCommunicationServer) StreamInlineCompletions(*InlineCompletionRequest, grpc.ServerStreamingServer[InlineCompletionEvent]) error {
	return status.Errorf(codes.Unimplemented, "method StreamInlineCompletions not implemented")
}
func (UnimplementedAgentCommunicationServer) ProposeEdits(context.Context, *ProposeEditsRequest) (*ProposeEditsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposeEdits not implemented")
}
func (UnimplementedAgentCommunicationServer) ApplyEdits(context.Context, *ApplyEditsRequest) (*ApplyEditsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyEdits not implemented")
}
func (UnimplementedAgentCommunicationServer) UpdateEditorState(context.Context, *UpdateEditorStateRequest) (*UpdateEditorStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateEditorState not implemented")
}
func (UnimplementedAgentCommunicationServer) mustEmbedUnimplementedAgentCommunicationServer() {}
func (UnimplementedAgentCommunicationServer) testEmbeddedByValue()                            {}

// UnsafeAgentCommunicationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentCommunicationServer will
// result in compilation errors.
type UnsafeAgentCommunicationServer interface {
	mustEmbedUnimplementedAgentCommunicationServer()
}

func RegisterAgentCommunicationServer(s grpc.ServiceRegistrar, srv AgentCommunicationServer) {
	// If the following call pancis, it indicates UnimplementedAgentCommunicationServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentCommunication_ServiceDesc, srv)
}

func _AgentCommunication_RegisterAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).RegisterAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_RegisterAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).RegisterAgent(ctx, req.(*RegisterAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_UnregisterAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).UnregisterAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_UnregisterAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).UnregisterAgent(ctx, req.(*UnregisterAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_DiscoverAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscoverAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).DiscoverAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_DiscoverAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).DiscoverAgents(ctx, req.(*DiscoverAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_GetAgentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).GetAgentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_GetAgentInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).GetAgentInfo(ctx, req.(*GetAgentInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_GetServerCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).GetServerCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_GetServerCapabilities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).GetServerCapabilities(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_RequestCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CapabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).RequestCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_RequestCapabilities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).RequestCapabilities(ctx, req.(*CapabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_RevokeCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CapabilityRevocation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).RevokeCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_RevokeCapabilities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).RevokeCapabilities(ctx, req.(*CapabilityRevocation))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_CreateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).CreateSession(ctx, req.(*CreateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_UpdateSessionContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextDelta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).UpdateSessionContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_UpdateSessionContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).UpdateSessionContext(ctx, req.(*ContextDelta))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_CreateContextHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextHandleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).CreateContextHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_CreateContextHandle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).CreateContextHandle(ctx, req.(*ContextHandleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_ResolveContextHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextHandle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).ResolveContextHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_ResolveContextHandle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).ResolveContextHandle(ctx, req.(*ContextHandle))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_StreamTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentCommunicationServer).StreamTask(m, &grpc.GenericServerStream[TaskStreamRequest, TaskEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentCommunication_StreamTaskServer = grpc.ServerStreamingServer[TaskEvent]

func _AgentCommunication_SubscribeTaskEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskSubscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentCommunicationServer).SubscribeTaskEvents(m, &grpc.GenericServerStream[TaskSubscription, TaskEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentCommunication_SubscribeTaskEventsServer = grpc.ServerStreamingServer[TaskEvent]

func _AgentCommunication_GetP2PEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(P2PEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).GetP2PEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_GetP2PEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).GetP2PEndpoint(ctx, req.(*P2PEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_EstablishP2PConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(P2PHandshake)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).EstablishP2PConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_EstablishP2PConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).EstablishP2PConnection(ctx, req.(*P2PHandshake))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_RequestToolExecution_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ToolExecutionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentCommunicationServer).RequestToolExecution(m, &grpc.GenericServerStream[ToolExecutionRequest, ToolExecutionEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentCommunication_RequestToolExecutionServer = grpc.ServerStreamingServer[ToolExecutionEvent]

func _AgentCommunication_ApproveToolExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToolApproval)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).ApproveToolExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_ApproveToolExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).ApproveToolExecution(ctx, req.(*ToolApproval))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_RejectToolExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToolRejection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).RejectToolExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_RejectToolExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).RejectToolExecution(ctx, req.(*ToolRejection))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).SendMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_StreamInlineCompletions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InlineCompletionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentCommunicationServer).StreamInlineCompletions(m, &grpc.GenericServerStream[InlineCompletionRequest, InlineCompletionEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentCommunication_StreamInlineCompletionsServer = grpc.ServerStreamingServer[InlineCompletionEvent]

func _AgentCommunication_ProposeEdits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposeEditsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).ProposeEdits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_ProposeEdits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).ProposeEdits(ctx, req.(*ProposeEditsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_ApplyEdits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyEditsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).ApplyEdits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_ApplyEdits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).ApplyEdits(ctx, req.(*ApplyEditsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentCommunication_UpdateEditorState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateEditorStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentCommunicationServer).UpdateEditorState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentCommunication_UpdateEditorState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentCommunicationServer).UpdateEditorState(ctx, req.(*UpdateEditorStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentCommunication_ServiceDesc is the grpc.ServiceDesc for AgentCommunication service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentCommunication_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "buckley.acp.v1.AgentCommunication",
	HandlerType: (*AgentCommunicationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterAgent",
			Handler:    _AgentCommunication_RegisterAgent_Handler,
		},
		{
			MethodName: "UnregisterAgent",
			Handler:    _AgentCommunication_UnregisterAgent_Handler,
		},
		{
			MethodName: "DiscoverAgents",
			Handler:    _AgentCommunication_DiscoverAgents_Handler,
		},
		{
			MethodName: "GetAgentInfo",
			Handler:    _AgentCommunication_GetAgentInfo_Handler,
		},
		{
			MethodName: "GetServerCapabilities",
			Handler:    _AgentCommunication_GetServerCapabilities_Handler,
		},
		{
			MethodName: "RequestCapabilities",
			Handler:    _AgentCommunication_RequestCapabilities_Handler,
		},
		{
			MethodName: "RevokeCapabilities",
			Handler:    _AgentCommunication_RevokeCapabilities_Handler,
		},
		{
			MethodName: "CreateSession",
			Handler:    _AgentCommunication_CreateSession_Handler,
		},
		{
			MethodName: "UpdateSessionContext",
			Handler:    _AgentCommunication_UpdateSessionContext_Handler,
		},
		{
			MethodName: "CreateContextHandle",
			Handler:    _AgentCommunication_CreateContextHandle_Handler,
		},
		{
			MethodName: "ResolveContextHandle",
			Handler:    _AgentCommunication_ResolveContextHandle_Handler,
		},
		{
			MethodName: "GetP2PEndpoint",
			Handler:    _AgentCommunication_GetP2PEndpoint_Handler,
		},
		{
			MethodName: "EstablishP2PConnection",
			Handler:    _AgentCommunication_EstablishP2PConnection_Handler,
		},
		{
			MethodName: "ApproveToolExecution",
			Handler:    _AgentCommunication_ApproveToolExecution_Handler,
		},
		{
			MethodName: "RejectToolExecution",
			Handler:    _AgentCommunication_RejectToolExecution_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _AgentCommunication_SendMessage_Handler,
		},
		{
			MethodName: "ProposeEdits",
			Handler:    _AgentCommunication_ProposeEdits_Handler,
		},
		{
			MethodName: "ApplyEdits",
			Handler:    _AgentCommunication_ApplyEdits_Handler,
		},
		{
			MethodName: "UpdateEditorState",
			Handler:    _AgentCommunication_UpdateEditorState_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamTask",
			Handler:       _AgentCommunication_StreamTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeTaskEvents",
			Handler:       _AgentCommunication_SubscribeTaskEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RequestToolExecution",
			Handler:       _AgentCommunication_RequestToolExecution_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamInlineCompletions",
			Handler:       _AgentCommunication_StreamInlineCompletions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "acp.proto",
}
