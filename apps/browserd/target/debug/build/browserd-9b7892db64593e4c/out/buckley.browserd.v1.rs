// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Envelope {
    #[prost(oneof = "envelope::Message", tags = "1, 2, 3")]
    pub message: ::core::option::Option<envelope::Message>,
}
/// Nested message and enum types in `Envelope`.
pub mod envelope {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        #[prost(message, tag = "1")]
        Request(super::Request),
        #[prost(message, tag = "2")]
        Response(super::Response),
        #[prost(message, tag = "3")]
        Event(super::StreamEvent),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Request {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(oneof = "request::Payload", tags = "3, 4, 5, 6, 7, 8")]
    pub payload: ::core::option::Option<request::Payload>,
}
/// Nested message and enum types in `Request`.
pub mod request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "3")]
        CreateSession(super::CreateSessionRequest),
        #[prost(message, tag = "4")]
        Navigate(super::NavigateRequest),
        #[prost(message, tag = "5")]
        Observe(super::ObserveRequest),
        #[prost(message, tag = "6")]
        Act(super::ActRequest),
        #[prost(message, tag = "7")]
        CloseSession(super::CloseSessionRequest),
        #[prost(message, tag = "8")]
        StreamSubscribe(super::StreamSubscribeRequest),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<Error>,
    #[prost(oneof = "response::Payload", tags = "4, 5, 6, 7, 8, 9")]
    pub payload: ::core::option::Option<response::Payload>,
}
/// Nested message and enum types in `Response`.
pub mod response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "4")]
        CreateSession(super::CreateSessionResponse),
        #[prost(message, tag = "5")]
        Navigate(super::NavigateResponse),
        #[prost(message, tag = "6")]
        Observe(super::ObserveResponse),
        #[prost(message, tag = "7")]
        Act(super::ActResponse),
        #[prost(message, tag = "8")]
        CloseSession(super::CloseSessionResponse),
        #[prost(message, tag = "9")]
        StreamSubscribe(super::StreamSubscribeResponse),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSessionRequest {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<SessionConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSessionResponse {
    #[prost(message, optional, tag = "1")]
    pub session: ::core::option::Option<SessionInfo>,
    #[prost(message, optional, tag = "2")]
    pub observation: ::core::option::Option<Observation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NavigateRequest {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NavigateResponse {
    #[prost(message, optional, tag = "1")]
    pub observation: ::core::option::Option<Observation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObserveRequest {
    #[prost(message, optional, tag = "1")]
    pub options: ::core::option::Option<ObserveOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObserveResponse {
    #[prost(message, optional, tag = "1")]
    pub observation: ::core::option::Option<Observation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActRequest {
    #[prost(message, optional, tag = "1")]
    pub action: ::core::option::Option<Action>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<ActionResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloseSessionRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloseSessionResponse {
    #[prost(bool, tag = "1")]
    pub closed: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamSubscribeRequest {
    #[prost(message, optional, tag = "1")]
    pub options: ::core::option::Option<StreamOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamSubscribeResponse {
    #[prost(bool, tag = "1")]
    pub subscribed: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionInfo {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub state_version: u64,
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionConfig {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub initial_url: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub viewport: ::core::option::Option<Viewport>,
    #[prost(string, tag = "4")]
    pub user_agent: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub locale: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub timezone: ::prost::alloc::string::String,
    #[prost(uint32, tag = "7")]
    pub frame_rate: u32,
    #[prost(string, repeated, tag = "8")]
    pub network_allowlist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "9")]
    pub clipboard: ::core::option::Option<ClipboardPolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Viewport {
    #[prost(uint32, tag = "1")]
    pub width: u32,
    #[prost(uint32, tag = "2")]
    pub height: u32,
    #[prost(double, tag = "3")]
    pub device_scale_factor: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClipboardPolicy {
    #[prost(enumeration = "ClipboardMode", tag = "1")]
    pub mode: i32,
    #[prost(bool, tag = "2")]
    pub allow_read: bool,
    #[prost(bool, tag = "3")]
    pub allow_write: bool,
    #[prost(uint32, tag = "4")]
    pub max_bytes: u32,
    #[prost(string, repeated, tag = "5")]
    pub read_allowlist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObserveOptions {
    #[prost(bool, tag = "1")]
    pub include_frame: bool,
    #[prost(bool, tag = "2")]
    pub include_dom_snapshot: bool,
    #[prost(bool, tag = "3")]
    pub include_accessibility: bool,
    #[prost(bool, tag = "4")]
    pub include_hit_test: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamOptions {
    #[prost(bool, tag = "1")]
    pub include_frames: bool,
    #[prost(bool, tag = "2")]
    pub include_dom_diffs: bool,
    #[prost(bool, tag = "3")]
    pub include_accessibility_diffs: bool,
    #[prost(bool, tag = "4")]
    pub include_hit_test: bool,
    #[prost(uint32, tag = "5")]
    pub target_fps: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Observation {
    #[prost(uint64, tag = "1")]
    pub state_version: u64,
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub frame: ::core::option::Option<Frame>,
    #[prost(bytes = "vec", tag = "5")]
    pub dom_snapshot: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub accessibility_tree: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "7")]
    pub hit_test: ::core::option::Option<HitTestMap>,
    #[prost(message, optional, tag = "8")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Frame {
    #[prost(uint64, tag = "1")]
    pub state_version: u64,
    #[prost(uint32, tag = "2")]
    pub width: u32,
    #[prost(uint32, tag = "3")]
    pub height: u32,
    #[prost(enumeration = "FrameFormat", tag = "4")]
    pub format: i32,
    #[prost(bytes = "vec", tag = "5")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HitTestMap {
    #[prost(uint32, tag = "1")]
    pub width: u32,
    #[prost(uint32, tag = "2")]
    pub height: u32,
    #[prost(message, repeated, tag = "3")]
    pub regions: ::prost::alloc::vec::Vec<HitRegion>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HitRegion {
    #[prost(uint64, tag = "1")]
    pub node_id: u64,
    #[prost(message, optional, tag = "2")]
    pub bounds: ::core::option::Option<Rect>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rect {
    #[prost(int32, tag = "1")]
    pub x: i32,
    #[prost(int32, tag = "2")]
    pub y: i32,
    #[prost(int32, tag = "3")]
    pub width: i32,
    #[prost(int32, tag = "4")]
    pub height: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Point {
    #[prost(int32, tag = "1")]
    pub x: i32,
    #[prost(int32, tag = "2")]
    pub y: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(enumeration = "ActionType", tag = "1")]
    pub r#type: i32,
    #[prost(uint64, tag = "2")]
    pub expected_state_version: u64,
    #[prost(message, optional, tag = "3")]
    pub target: ::core::option::Option<ActionTarget>,
    #[prost(string, tag = "4")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub scroll: ::core::option::Option<ScrollDelta>,
    #[prost(enumeration = "KeyModifier", repeated, tag = "7")]
    pub modifiers: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionTarget {
    #[prost(uint64, tag = "1")]
    pub node_id: u64,
    #[prost(message, optional, tag = "2")]
    pub point: ::core::option::Option<Point>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScrollDelta {
    #[prost(int32, tag = "1")]
    pub x: i32,
    #[prost(int32, tag = "2")]
    pub y: i32,
    #[prost(enumeration = "ScrollUnit", tag = "3")]
    pub unit: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionResult {
    #[prost(uint64, tag = "1")]
    pub state_version: u64,
    #[prost(message, optional, tag = "2")]
    pub observation: ::core::option::Option<Observation>,
    #[prost(message, repeated, tag = "3")]
    pub effects: ::prost::alloc::vec::Vec<Effect>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Effect {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub summary: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamEvent {
    #[prost(enumeration = "StreamEventType", tag = "1")]
    pub r#type: i32,
    #[prost(uint64, tag = "2")]
    pub state_version: u64,
    #[prost(message, optional, tag = "3")]
    pub frame: ::core::option::Option<Frame>,
    #[prost(bytes = "vec", tag = "4")]
    pub dom_diff: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub accessibility_diff: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "6")]
    pub hit_test: ::core::option::Option<HitTestMap>,
    #[prost(message, optional, tag = "7")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClipboardMode {
    Unspecified = 0,
    Virtual = 1,
    Host = 2,
}
impl ClipboardMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ClipboardMode::Unspecified => "CLIPBOARD_MODE_UNSPECIFIED",
            ClipboardMode::Virtual => "CLIPBOARD_MODE_VIRTUAL",
            ClipboardMode::Host => "CLIPBOARD_MODE_HOST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLIPBOARD_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "CLIPBOARD_MODE_VIRTUAL" => Some(Self::Virtual),
            "CLIPBOARD_MODE_HOST" => Some(Self::Host),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FrameFormat {
    Unspecified = 0,
    Png = 1,
    Jpeg = 2,
    Webp = 3,
}
impl FrameFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FrameFormat::Unspecified => "FRAME_FORMAT_UNSPECIFIED",
            FrameFormat::Png => "FRAME_FORMAT_PNG",
            FrameFormat::Jpeg => "FRAME_FORMAT_JPEG",
            FrameFormat::Webp => "FRAME_FORMAT_WEBP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FRAME_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "FRAME_FORMAT_PNG" => Some(Self::Png),
            "FRAME_FORMAT_JPEG" => Some(Self::Jpeg),
            "FRAME_FORMAT_WEBP" => Some(Self::Webp),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ScrollUnit {
    Unspecified = 0,
    Pixels = 1,
    Lines = 2,
}
impl ScrollUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ScrollUnit::Unspecified => "SCROLL_UNIT_UNSPECIFIED",
            ScrollUnit::Pixels => "SCROLL_UNIT_PIXELS",
            ScrollUnit::Lines => "SCROLL_UNIT_LINES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCROLL_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
            "SCROLL_UNIT_PIXELS" => Some(Self::Pixels),
            "SCROLL_UNIT_LINES" => Some(Self::Lines),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActionType {
    Unspecified = 0,
    Click = 1,
    Type = 2,
    Scroll = 3,
    Hover = 4,
    Key = 5,
    Focus = 6,
    ClipboardRead = 7,
    ClipboardWrite = 8,
}
impl ActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ActionType::Unspecified => "ACTION_TYPE_UNSPECIFIED",
            ActionType::Click => "ACTION_TYPE_CLICK",
            ActionType::Type => "ACTION_TYPE_TYPE",
            ActionType::Scroll => "ACTION_TYPE_SCROLL",
            ActionType::Hover => "ACTION_TYPE_HOVER",
            ActionType::Key => "ACTION_TYPE_KEY",
            ActionType::Focus => "ACTION_TYPE_FOCUS",
            ActionType::ClipboardRead => "ACTION_TYPE_CLIPBOARD_READ",
            ActionType::ClipboardWrite => "ACTION_TYPE_CLIPBOARD_WRITE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTION_TYPE_CLICK" => Some(Self::Click),
            "ACTION_TYPE_TYPE" => Some(Self::Type),
            "ACTION_TYPE_SCROLL" => Some(Self::Scroll),
            "ACTION_TYPE_HOVER" => Some(Self::Hover),
            "ACTION_TYPE_KEY" => Some(Self::Key),
            "ACTION_TYPE_FOCUS" => Some(Self::Focus),
            "ACTION_TYPE_CLIPBOARD_READ" => Some(Self::ClipboardRead),
            "ACTION_TYPE_CLIPBOARD_WRITE" => Some(Self::ClipboardWrite),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyModifier {
    Unspecified = 0,
    Shift = 1,
    Alt = 2,
    Ctrl = 3,
    Meta = 4,
}
impl KeyModifier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            KeyModifier::Unspecified => "KEY_MODIFIER_UNSPECIFIED",
            KeyModifier::Shift => "KEY_MODIFIER_SHIFT",
            KeyModifier::Alt => "KEY_MODIFIER_ALT",
            KeyModifier::Ctrl => "KEY_MODIFIER_CTRL",
            KeyModifier::Meta => "KEY_MODIFIER_META",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEY_MODIFIER_UNSPECIFIED" => Some(Self::Unspecified),
            "KEY_MODIFIER_SHIFT" => Some(Self::Shift),
            "KEY_MODIFIER_ALT" => Some(Self::Alt),
            "KEY_MODIFIER_CTRL" => Some(Self::Ctrl),
            "KEY_MODIFIER_META" => Some(Self::Meta),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StreamEventType {
    Unspecified = 0,
    Frame = 1,
    DomDiff = 2,
    AccessibilityDiff = 3,
    HitTest = 4,
}
impl StreamEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StreamEventType::Unspecified => "STREAM_EVENT_TYPE_UNSPECIFIED",
            StreamEventType::Frame => "STREAM_EVENT_TYPE_FRAME",
            StreamEventType::DomDiff => "STREAM_EVENT_TYPE_DOM_DIFF",
            StreamEventType::AccessibilityDiff => "STREAM_EVENT_TYPE_ACCESSIBILITY_DIFF",
            StreamEventType::HitTest => "STREAM_EVENT_TYPE_HIT_TEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STREAM_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "STREAM_EVENT_TYPE_FRAME" => Some(Self::Frame),
            "STREAM_EVENT_TYPE_DOM_DIFF" => Some(Self::DomDiff),
            "STREAM_EVENT_TYPE_ACCESSIBILITY_DIFF" => Some(Self::AccessibilityDiff),
            "STREAM_EVENT_TYPE_HIT_TEST" => Some(Self::HitTest),
            _ => None,
        }
    }
}
